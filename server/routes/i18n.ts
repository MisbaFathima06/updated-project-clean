import { Router } from 'express';

const router = Router();

const translations = {
  en: {
    'hero.title': 'Your Voice, Your Safety',
    'hero.subtitle': 'Completely Anonymous',
    'hero.description': 'Report sensitive issues with zero-knowledge privacy. Your identity stays protected while your voice creates change.',
    'hero.submit_report': 'Submit Anonymous Report',
    'hero.track_status': 'Track Status',
    'zk.status': 'Zero-Knowledge Identity: Active',
    'zk.active': 'Zero-Knowledge Identity Active',
    'zk.generating': 'Generating Identity...',
    'features.anonymous.title': '100% Anonymous',
    'features.anonymous.description': 'Zero-knowledge proofs ensure your identity remains completely private while proving authenticity.',
    'features.encrypted.title': 'End-to-End Encrypted',
    'features.encrypted.description': 'Military-grade AES encryption ensures your complaints are secure from submission to resolution.',
    'features.blockchain.title': 'Blockchain Verified',
    'features.blockchain.description': 'Immutable proof of submission stored on blockchain prevents tampering and ensures transparency.',
    'impact.title': 'Real Impact Stories',
    'impact.quote': 'For the first time, I felt safe to speak.',
    'impact.story': 'I had faced something no one should ever go through. But fear of being blamed, judged, or exposed kept me silent. Then I found SpeakSecure. It let me report everything anonymously. No one knew who I was, but someone finally listened. The NGO team took action ‚Äî and for once, I felt seen, heard, and protected.',
    'impact.attribution': '‚Äî Anonymous Survivor, India',
    'impact.outcome': 'Sexual assault case addressed ‚Ä¢ July 2025',
    'emergency': 'Emergency',
    'report.title': 'Submit Your Report',
    'report.description': 'Your identity remains completely anonymous. All data is encrypted before transmission.',
    'form.category': 'Complaint Category',
    'form.select_category': 'Select a category...',
    'categories.harassment': 'Workplace Harassment',
    'categories.abuse': 'Physical/Mental Abuse',
    'categories.discrimination': 'Discrimination',
    'categories.corruption': 'Corruption',
    'categories.safety': 'Public Safety',
    'categories.legal': 'Legal Issues',
    'categories.other': 'Other',
    'app.title': 'SpeakSecure',
    'complaint.submit': 'Submit Complaint',
    'complaint.status': 'Check Status',
    'complaint.topic': 'Topic',
    'complaint.description': 'Description',
    'complaint.location': 'Location',
    'complaint.urgency': 'Urgency',
    'emergency.contact': 'Emergency Contact',
    'status.submitted': 'Submitted',
    'status.review': 'Under Review',
    'status.investigation': 'Under Investigation',
    'status.resolved': 'Resolved'
  },
  hi: {
    'hero.title': '‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º, ‡§Ü‡§™‡§ï‡•Ä ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§æ',
    'hero.subtitle': '‡§™‡•Ç‡§∞‡•ç‡§£‡§§‡§É ‡§ó‡•Å‡§Æ‡§®‡§æ‡§Æ',
    'hero.description': '‡§∂‡•Ç‡§®‡•ç‡§Ø-‡§ú‡•ç‡§û‡§æ‡§® ‡§ó‡•ã‡§™‡§®‡•Ä‡§Ø‡§§‡§æ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§∏‡§Ç‡§µ‡•á‡§¶‡§®‡§∂‡•Ä‡§≤ ‡§Æ‡•Å‡§¶‡•ç‡§¶‡•ã‡§Ç ‡§ï‡•Ä ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§Ü‡§™‡§ï‡•Ä ‡§™‡§π‡§ö‡§æ‡§® ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§∞‡§π‡§§‡•Ä ‡§π‡•à ‡§ú‡§¨‡§ï‡§ø ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§¨‡§¶‡§≤‡§æ‡§µ ‡§≤‡§æ‡§§‡•Ä ‡§π‡•à‡•§',
    'hero.submit_report': '‡§ó‡•Å‡§Æ‡§®‡§æ‡§Æ ‡§∞‡§ø‡§™‡•ã‡§∞‡•ç‡§ü ‡§∏‡§¨‡§Æ‡§ø‡§ü ‡§ï‡§∞‡•á‡§Ç',
    'hero.track_status': '‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§ü‡•ç‡§∞‡•à‡§ï ‡§ï‡§∞‡•á‡§Ç',
    'emergency': '‡§Ü‡§™‡§æ‡§§‡§ï‡§æ‡§≤',
    'form.category': '‡§∂‡§ø‡§ï‡§æ‡§Ø‡§§ ‡§∂‡•ç‡§∞‡•á‡§£‡•Ä',
    'categories.harassment': '‡§ï‡§æ‡§∞‡•ç‡§Ø‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞ ‡§â‡§§‡•ç‡§™‡•Ä‡§°‡§º‡§®',
    'categories.abuse': '‡§∂‡§æ‡§∞‡•Ä‡§∞‡§ø‡§ï/‡§Æ‡§æ‡§®‡§∏‡§ø‡§ï ‡§¶‡•Å‡§∞‡•ç‡§µ‡•ç‡§Ø‡§µ‡§π‡§æ‡§∞',
    'categories.discrimination': '‡§≠‡•á‡§¶‡§≠‡§æ‡§µ',
    'categories.corruption': '‡§≠‡•ç‡§∞‡§∑‡•ç‡§ü‡§æ‡§ö‡§æ‡§∞',
    'categories.safety': '‡§∏‡§æ‡§∞‡•ç‡§µ‡§ú‡§®‡§ø‡§ï ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§æ',
    'categories.legal': '‡§ï‡§æ‡§®‡•Ç‡§®‡•Ä ‡§Æ‡•Å‡§¶‡•ç‡§¶‡•á',
    'categories.other': '‡§Ö‡§®‡•ç‡§Ø',
    'app.title': '‡§∏‡•ç‡§™‡•Ä‡§ï‡§∏‡§ø‡§ï‡•ç‡§Ø‡•ã‡§∞',
    'complaint.submit': '‡§∂‡§ø‡§ï‡§æ‡§Ø‡§§ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç',
    'complaint.status': '‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§ú‡§æ‡§Ç‡§ö‡•á‡§Ç',
    'complaint.topic': '‡§µ‡§ø‡§∑‡§Ø',
    'complaint.description': '‡§µ‡§ø‡§µ‡§∞‡§£',
    'complaint.location': '‡§∏‡•ç‡§•‡§æ‡§®',
    'complaint.urgency': '‡§§‡§æ‡§§‡•ç‡§ï‡§æ‡§≤‡§ø‡§ï‡§§‡§æ',
    'emergency.contact': '‡§Ü‡§™‡§æ‡§§‡§ï‡§æ‡§≤‡•Ä‡§® ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï',
    'status.submitted': '‡§™‡•ç‡§∞‡§∏‡•ç‡§§‡•Å‡§§',
    'status.review': '‡§∏‡§Æ‡•Ä‡§ï‡•ç‡§∑‡§æ‡§ß‡•Ä‡§®',
    'status.investigation': '‡§ú‡§æ‡§Ç‡§ö ‡§ï‡•á ‡§§‡§π‡§§',
    'status.resolved': '‡§π‡§≤ ‡§π‡•ã ‡§ó‡§Ø‡§æ'
  },
  ta: {
    'hero.title': '‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æï‡ØÅ‡Æ∞‡Æ≤‡Øç, ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡ØÅ',
    'hero.subtitle': '‡ÆÆ‡ØÅ‡Æ±‡Øç‡Æ±‡Æø‡Æ≤‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ®‡Ææ‡ÆÆ‡Æ§‡Øá‡ÆØ',
    'hero.description': '‡Æ™‡ØÇ‡Æú‡Øç‡ÆØ-‡ÆÖ‡Æ±‡Æø‡Æµ‡ØÅ ‡Æ§‡Æ©‡Æø‡ÆØ‡ØÅ‡Æ∞‡Æø‡ÆÆ‡Øà‡ÆØ‡ØÅ‡Æü‡Æ©‡Øç ‡Æâ‡Æ£‡Æ∞‡Øç‡Æ§‡Æø‡Æ±‡Æ©‡Øç ‡Æ™‡Æø‡Æ∞‡Æö‡Øç‡Æö‡Æø‡Æ©‡Øà‡Æï‡Æ≥‡Øà‡Æ™‡Øç ‡Æ™‡ØÅ‡Æï‡Ææ‡Æ∞‡Æ≥‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.',
    'emergency': '‡ÆÖ‡Æµ‡Æö‡Æ∞‡Æ®‡Æø‡Æ≤‡Øà'
  },
  kn: {
    'hero.title': '‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤ß‡≥ç‡≤µ‡≤®‡≤ø, ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤∏‡≥Å‡≤∞‡≤ï‡≥ç‡≤∑‡≤§‡≥Ü',
    'hero.subtitle': '‡≤∏‡≤Ç‡≤™‡≥Ç‡≤∞‡≥ç‡≤£‡≤µ‡≤æ‡≤ó‡≤ø ‡≤Ö‡≤ú‡≥ç‡≤û‡≤æ‡≤§',
    'emergency': '‡≤§‡≥Å‡≤∞‡≥ç‡≤§‡≥Å‡≤∏‡≥ç‡≤•‡≤ø‡≤§‡≤ø'
  },
  ur: {
    'hero.title': 'ÿ¢Ÿæ ⁄©€å ÿ¢Ÿàÿßÿ≤ÿå ÿ¢Ÿæ ⁄©€å ÿ≠ŸÅÿßÿ∏ÿ™',
    'hero.subtitle': 'ŸÖ⁄©ŸÖŸÑ ÿ∑Ÿàÿ± Ÿæÿ± ⁄ØŸÖŸÜÿßŸÖ',
    'emergency': '€ÅŸÜ⁄ØÿßŸÖ€å ÿ≠ÿßŸÑÿßÿ™'
  }
};

const supportedLanguages = [
  { code: 'en', name: 'English', flag: 'üá∫üá∏' },
  { code: 'hi', name: '‡§π‡§ø‡§Ç‡§¶‡•Ä', flag: 'üáÆüá≥' },
  { code: 'ta', name: '‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç', flag: 'üáÆüá≥' },
  { code: 'kn', name: '‡≤ï‡≤®‡≥ç‡≤®‡≤°', flag: 'üáÆüá≥' },
  { code: 'ur', name: 'ÿßÿ±ÿØŸà', flag: 'üáµüá∞' },
];

// Get translations for a specific language
router.get('/:language', async (req, res) => {
  try {
    const { language } = req.params;
    
    // Check if language is supported
    const supportedLanguageCodes = supportedLanguages.map(lang => lang.code);
    if (!supportedLanguageCodes.includes(language)) {
      return res.status(400).json({
        success: false,
        error: 'Unsupported language',
        supportedLanguages: supportedLanguageCodes
      });
    }

    const languageTranslations = translations[language as keyof typeof translations];
    
    if (!languageTranslations) {
      // Fallback to English if language translations are not found
      console.log(`‚ö†Ô∏è Falling back to English for language: ${language}`);
      const englishTranslations = translations.en;
      return res.json({
        success: true,
        language: 'en',
        translations: englishTranslations,
        message: 'Returned English translations as fallback'
      });
    }

    console.log(`üåê Serving translations for language: ${language}`);

    res.json({
      success: true,
      language,
      translations: languageTranslations,
      meta: {
        totalKeys: Object.keys(languageTranslations).length,
        lastUpdated: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('Failed to get translations:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve translations'
    });
  }
});

// Get all supported languages
router.get('/', async (req, res) => {
  try {
    res.json({
      success: true,
      supportedLanguages,
      defaultLanguage: 'en',
      totalLanguages: supportedLanguages.length
    });

  } catch (error) {
    console.error('Failed to get supported languages:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve supported languages'
    });
  }
});

// Get specific translation key for a language
router.get('/:language/:key', async (req, res) => {
  try {
    const { language, key } = req.params;
    
    // Check if language is supported
    const supportedLanguageCodes = supportedLanguages.map(lang => lang.code);
    if (!supportedLanguageCodes.includes(language)) {
      return res.status(400).json({
        success: false,
        error: 'Unsupported language'
      });
    }

    let languageTranslations = translations[language as keyof typeof translations];
    if (!languageTranslations) {
      console.log(`‚ö†Ô∏è Falling back to English for key lookup: ${language}/${key}`);
      languageTranslations = translations.en;
    }

    // Navigate nested keys (e.g., "hero.title")
    const keys = key.split('.');
    let value: any = languageTranslations;
    
    for (const k of keys) {
      if (value && typeof value === 'object') {
        value = value[k];
      } else {
        value = undefined;
        break;
      }
    }

    if (value === undefined) {
      // Fallback to English if the key is not found in the requested language
      let fallback: any = translations.en;
      for (const k of keys) {
        if (fallback && typeof fallback === 'object') {
          fallback = fallback[k];
        } else {
          fallback = undefined;
          break;
        }
      }

      if (fallback === undefined) {
        return res.status(404).json({
          success: false,
          error: 'Translation key not found',
          key
        });
      }

      res.json({
        success: true,
        language: language, // original requested language
        key,
        value: fallback,
        fallback: true,
        message: 'Returned English fallback'
      });
    } else {
      res.json({
        success: true,
        language,
        key,
        value,
        fallback: false
      });
    }

  } catch (error) {
    console.error('Failed to get translation key:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve translation'
    });
  }
});

// Set user language preference (for future features)
router.post('/preference', async (req, res) => {
  try {
    const { language, userId } = req.body;

    if (!language) {
      return res.status(400).json({
        success: false,
        error: 'Language is required'
      });
    }

    const supportedLanguageCodes = supportedLanguages.map(lang => lang.code);
    if (!supportedLanguageCodes.includes(language)) {
      return res.status(400).json({
        success: false,
        error: 'Unsupported language'
      });
    }

    // In a real implementation, you would save this to user preferences
    // For now, just acknowledge the preference
    console.log(`üë§ User language preference set: ${language}`);

    res.json({
      success: true,
      language,
      message: 'Language preference saved',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('Failed to set language preference:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to save language preference'
    });
  }
});

// Get translation statistics
router.get('/stats/coverage', async (req, res) => {
  try {
    const stats = supportedLanguages.map(lang => {
      const langTranslations = translations[lang.code];
      const keyCount = langTranslations ? Object.keys(langTranslations).length : 0;
      const englishKeyCount = Object.keys(translations.en).length;
      const coverage = englishKeyCount > 0 ? (keyCount / englishKeyCount) * 100 : 0;

      return {
        language: lang.code,
        name: lang.name,
        flag: lang.flag,
        keyCount,
        coverage: Math.round(coverage * 100) / 100
      };
    });

    res.json({
      success: true,
      stats,
      totalLanguages: supportedLanguages.length,
      baseLanguage: 'en'
    });

  } catch (error) {
    console.error('Failed to get translation stats:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve translation statistics'
    });
  }
});

export default router;